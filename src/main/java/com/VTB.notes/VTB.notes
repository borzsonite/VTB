
1. Вся статика инициализируется когда класс загружается в память, класс загружается в память когда к нему впервые обращаются (это может быть обращение к статическому полю, методу, создание объекта)

2. Вызвать нестататический метод из статического можно только через экземпляр класса экземпляр.nonStaticMethod();

3. Объект храниться в куче, ссылка на него храниться в стэке.

4. Когда программа начинает выполняться в стек попдают вызовы методов и локальные переменные

5. Ссылки на объекты храняться в стеке, но если у объекта есть ссылка на другой объект, то такая ссылка будет храниться вместе с объектом в куче.

6. Локальной переменной нельзя пользоваться пока она не инициализирована, т.е локальные переменные по умолчанию не инициализируются.

7. По умолчанию инициализируются поля объектов.

8. Если необходимо чтобы поля родителя перешли к наследникам у них убирается модификатор private.

9. Абстрактные методы могут находится только внутри абстрактного класса.

10. Если объект наследник ссылается на родительскую ссылку:
    Animal animal = new Dog("Bobik", "White", 2);
то по такой ссылке напрямую можно вызывать только методы родителя:
    animal.helloFromAnimal();
    animal.helloFromDog(); // так не работает, потому что теоретически на Animal можно сослать и Dog и Cat и Hamster etc и тогда может возникнуть возможность у хомяка вызвать метод собаки.
чтобы вызвать метод наследника, нужно сделать принудительный каст, явно указав что по ссылке Animal находится Dog
    ((Dog)animal).helloFromDog();

11. Положить в ссылку наследника объект родителя нельзя:
    Cat cat = new Animal(); // так не работает, потому что родитель не знает какие методы есть у наследника.

12. Если несколько классов имплементят один интерфейс их можно положить в переменную этого интерфейса, даже если они сильно отличаются. Например, Interface Flyable, на переменную типа Flyable можно ссылать объекты Duck, Airplane, Fly etc... Flyable fly = new Fly(), Flyable Duck = new Duck().

13. Если в интерфейсную переменную кладется объет релализующий несколько интерфейсов, то для вызовва метода одного из интерфейса, необходимо будет сделать каст к этому интерфейсу, (Swimable) duck.swim(), где swim - метод интерфейса Swimable.

14. Внутренние вложенные классы служать для организации кода, чтобы не выносить наружу то, что требуется лишь контексте внешнего класса. Например класс шахматная клетка имее смысл только в контексте класса шахматная доска, поэтому логично создать внутренний класс клетка внутри класса шахматная доска.

15. Внутренний аннонимный класс имеет название класса в котором он был образован с добаление $порядковыйНомер, например SomeClass$1

14. Смысл дефолтных методов в том, что дефолтные методы могут реализовываться всеми классами имплиментирующими интерфейс, при этом если в каком то классе нужно изменить логику дефолтного метода это не отразится на остальных классах реализующих данный интерфейс.

15. В назаваниях пакетов большие буквы недопустимы.

16. В распечатке stacktrace место, которое вызвало ошибку печатся во второй строке, например:
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at com.lesson3.MainApp.a(MainApp.java:14) // 3. здесь возникла ошибка
    	at com.lesson3.MainApp.b(MainApp.java:9) // 2. потом был вызов сюда
    	at com.lesson3.MainApp.main(MainApp.java:5) // 1.  путь к ошибке начался отсюда

17. Смысл пробрасывания исключения наверх не в том, чтобы загасить его в самом начале (в месте откуда оно вылетело), а в том чтобы обработать его на том этапе где это будет максимально полезно с точки зрения логики работы программы

////////////////////Lesson 4. Generis, Collections//////////////////////

18. Запись <T extends superclass> означает, что параметр Т может быть заменен только суперклассом или его подкассами

19. Никакой статический член не может использовать тип параметра, объявленный в его классе:

public class WrongGenericClass<T> {
   static Т data; // Неверно, нельзя создать статические переменные типа Т

   static Т getData() {
     return  data; }  // Неверно, ни один статический метод не может использовать Т
}

20. Нельзя объявить статические члены, использующие обобщённый тип. Но можно объявлять
    обобщённые статические методы, определяющие их собственные параметры типа.

21. Обобщённый класс не может расширять класс Throwable. Значит, создать обобщённые классы
    исключений невозможно.

22. Класс ArrayList, как и все коллекции в целом, может работать только с ссылочными типами
    данных. Для хранения примитивов необходимо использовать “обертки”: Byte, Short, Integer, Long,
    Float, Double, Character, Boolean.

23. Выводы по ДЗ3: прежде чем проводить какие-то вычисления необходимо проверить корректность входных данных, иначе к концу вычеслений может выясниться, что данные не верны и программа упадет затратив перед этим ресурсы.

24. Внутри обобщенного класса нельзя создавать объекты обобщеного типа:
void doSomething() {
   T obj = new T();
 }
 также нельзя создавать дженирализованные массивы: Т[] array = new T[10]; // так нельзя

25. В  дженериках наследование не работает, те. нельзя написать : GenBox<Number> gbx = new GenBox<Integer>(123); в правой части выражения должен быть тот же тип, что и в левой GenBox<Integer> gbx = new GenBox<Integer>(123);

26. public static void doSomething(GenBox<? super Number>) {} означает что метод принимает GenBox параметризованый Number или его родителями.

27. Существуют тажке параметризованные интерфейсы, например Comparable<>, его удобно применять при сравненни классов, например
    Class Box implement Comparable<Box> {

    @override
    comareTo(Box o) {
        return this.size - o.size;
    }
    }

28. Метод copy(List<? super T> consumer, List<? extends T> producer) PECS. Допустим consumer - лист животных, а producer - лист котов. Котов можно скопировать в лист животных, а животных в лист котов нельзя.

29. Varargs может быть только один, и должен стоять последним в списке аргументов.

////////////////////////COLLECTIONS//////////////////////
30. Начальная емкость ArrayList = 10 элементам и по мерер расширения увеличивается в 1.5 раза

31. Пример удалить все буквы "В" в листе: while(list.remove("B");

32. При создании новых классов если предполагается их сравнение у них нужно переопределить методы equals(), hashcode();

33. Отсортировать коллекцию можно двумя способоми:
    1. вызывать у коллекции метод sort(Comparator<? super T> c)
    2. вызвать у утильного класса Collections метод sort(Collection c, Comparator <? super T> c) переадав в него коллекцию и компаратор, пример:

    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "BBB", "CC", "GGGGG", "YYYY"));
        list.sort((o1, o2) -> o1.length() - o2.length()); // Способ 1
        Collections.sort(list, (o1, o2) -> o1.length() - o2.length()); // Способ 2

        System.out.println(list);
    }

34. Поиск элемента по индексу в LinkedList происходит путем прохода по всем элементам начиная с первого (или последнего) и подсчета количества переходов. Поэтому поиск по индексу здесь дольше чем в ArrayList

/////////////////////Lesson5 07.04.2021//////////////////////
35. Рехэшинг пересчет хэшей элементов в хэшмэп при увлеличении ее емкости

36. Loadfactor в хэшмапе указывает на то насколько должна быть заполнена хэшмэп, чтобы начачть увеличиваться (увеличение происходит в 2 раза)

37. метод HashMap.getOrDefault(key, DefaultValue), если ключ существует возвращает содержащееся по нему значение, иначе возвращет DefaultValue

38. HashMap<> не гарантирует порядко добавления/извлечения, если необходим порядок нужн использовать LinkedHashMap<>. TreeMap<> хранить значения в упорядоченном по ключу виде.

39. Интерфейс Set реализуется классами ashSet<> - порядок добавления/извлечения не гарантируется, LinkedHashSet - порядок гарантируется, TreeSet - хранит значения в отсортированом виде.

40. Особенность Set - в нем храняться только уникальные значения.

41. HashMap позволяет использовать null в  качестве ключей и значений, HashTable - не позволяет. Еще отличие HashMap не synchronized, HashTable synchronized

42. Vector и  ArrayList практически то же самое, различие Vector- synchronized, ArrayList - не synchronized

43. В момомент обхода коллекции (напр. foreach) ее нельзя модифицировать (удалалять, добавлять элементы)

44. Стандартный алгоритм обхода и изменения коллекции:
         List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "A"));
         Iterator<String> iterator = list.iterator(); // 1. Создаем итератор
            while(iterator.hasNext()) { // 2. Обходим коллекцию пока в ней есть следующее значение
              if(iterator.next().equals("A")) { // 3. Если условие выполняется
                 iterator.remove(); // 4. Производим действие
                }

45.  Iterator подходит для обхода Set и  List, для обхода HashMap Iterator не подходит. Но это ограничение можно обойти если применить итератор к EntrySet мапы. - map.entrySet().iterator();

46. Для обхода листов предусмотрен более специализированный listIterator() у которого есть большее количество методов для работы с листами. list.listIterator().nextIndex();

47. Простой способ вывести все пары ключ:значение в мапе:
    data.forEach((x,y)-> System.out.println(x + ": " + y));

/////////////////Lesson6//////////////////////
48. Поток демон будет работать пока работает хотя бы один обычный Поток. Как только все обычные Потоки завершаться демон тоже завершается.

49. Для остановки потока испльзуется метод thread.interupt(), затем в безопасном месте кода делается проверка на thread.isinterupted(), если возвращается true делается выход из потока.

50. При испольовании synchronized при вызове метода в качестве монитора испльзуется this, т.е. объект на котором был вызван метод.

51. Смысл обработки InteruptedException в том, что кто-то может попытаться оставновить поток который в данный момент недоступен (спит) в этом случае нужно предпринять какие то действия.

52. Синхронизированным можно делать не весь, а часть метода,

public class Test1 {
    Object monitor = new Object();

    public static void main(String[] args) {
        Test1 monitor = new Test1();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();

    }

    public void  method() {
        // non synchronized block --> сюда зайдут три потока одновременно !!!!!!!!!!!!!!
        System.out.println(Thread.currentThread().getName() + " non sync starts");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // synchronized block --> а сюда только по очереди !!!!!!!!!!!!!!
        synchronized (monitor) {
            System.out.println(Thread.currentThread().getName() + " sync starts");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

53. Если метод статический, то в качестве монитора выступает сам класс и доступ к такому методу одномоментно имеет только один поток.

54. Как только синхронизированный метод любого объекта получает управление, объект блокируется и ни один синхронизированный метод этого объекта не может быть вызван другим потоком. Скорее всего так потому, что объект блокируется по this, если в synchronized передавать разные объекты, то можно вызывать синхронизованные методы и блоки кода если они лочаться разными мониторами.

55. Если во внутренний (анонимный) класс передается извне какая-то переменная, то эта переменаня должна быть либо final, либо effectivly final

56. Существует 3 вида ThreadPool: 1. FixedTreadPool(4) - на определенной количество потоков, SingleThreadPool - на 1 поток, CachedThreadPool - на неограниченное количество потоков.

57. Если синхронизованный блок занят каким то потоком, то остальные потоки, которым тоже нужно попасть в этот блок, будут ждать (и ничего не делать) пока освободиться этот блок.

58. Hashtable лучше не использовать, потому что в качестве монитора выступает сама таблица соответственно она блокируется целиком. В этом случае лучше брать concurrentHashMap/

59. Преимущество CuncurrentHashTable в том, что при записи блокируется только та ячейка в которую проводится запись остальные ячейки остаются незаблокированными.

60. Для получения синхронизированнной коллекции из обычной можно использовать методы класса Collections
     Collections.synchronizedList()
     Collections.synchronizedMap()
     Collections.synchronizedSet()

     //////////////////////LESSON 8 Stream API////////////////////////////

61. При работе стрима исходная коллекция не меняется.

62. Простой способ получить заполненный лист List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
передать в конструктор лист.

63. Метод .map() служит для преобразования одних типов объектов в другой тип, например преобразование стрингов в интеджер
  Stream.of("AA", "D", "CCC", "NN").map(s -> s.length()).forEach(System.out::println); // 2 1 3 2
  или могут проводиться операции над одними типами например интеджер в интеджер:
    Stream.of(1, 2, 3, 4).map(s -> s + 1).forEach(System.out::println); // 2 3 4 5

64. Ссылка на метод примеры код в файле Test1.java:
 Stream.of("aa", "bb").map(String::length).forEach(System.out::println); // для каждого объекта типа String в потоке вызвать метод .length()
 Stream.of("aa", "bb").map(s -> s.length()).forEach(System.out::println); // то же самое

 Stream.of("Bob", "Mike", "Jhon").map(User::new).forEach(User::getName); // для каждого объекта типа User в потоке вызвать метод new() т.е. конструктор, а затем метод .getName();
 Stream.of("Bob", "Mike", "Jhon").map(s-> new User(s)).forEach(s -> s.getName()); // то же самое

65. Метод limit(n) оставляет в стриме n первых объектов.

66. Метод .distinct() оставляет в стриме только уникальные элементы:
        Arrays.asList(1,2,3,4,1,2,2).stream().distinct().forEach(System.out::println); // 1 2 3 4
        Arrays.asList("Jhon", "Mike", "Jhon").stream().distinct().forEach(System.out::println); // Jhon Mike

67. //math example
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().allMatch(s -> s > 0)); // true. Все элементы больше 0
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().anyMatch(s -> s > 10)); // false. Хоть один элмент стрима больше 10
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().noneMatch(s -> s == 7)); // false. Не один элемент не равен 7

68. .findAny() // возвращает Optional т.е. если объект есть возвращается этот объект обернутый в  Optional, если нет возвращается Optional.empty

69. Лямбды и ссылки на методы можно записывать в переменные и затем передавать в стримы, напр.:
        Consumer<Integer> consumer = System.out::println; // 1.1 Записываем в переменную ссылку на метод и
        Consumer<Integer> consumer1 = s -> System.out.print(s); 2.1 Записываем в переменную лямбду и

        Stream.of(1,2,3,4,5,1,2,3,4,5).forEach(consumer); // 1.2 передаем ее в качестве аргумента в стрим
        Stream.of(1,2,3,4,5,1,2,3,4,5).forEach(consumer1);2.2. передаем ее в качестве аргумента в стрим

70. // .reduce() example Служит для сжатия стрима в один объект, например:
    System.out.println(Stream.of(1,2,3,4).reduce(0, (a,b) -> a+b)); // стрим интеджеров преобразуется в сумму его значений.

71. Существуют специфические виды стримов IntStream, LongStream, DoubleStream которые содержат  специфические методы для работы с числами sum() avarage()

72. .mapToInt() example, метод служит для преобразования стрима объектов в стрим интов, например:
Stream.of(new User2("Bob", 20)).mapToInt(User2::getAge).forEach(System.out::println); // 20

73. .skip(n) // пропускает первые n элементов стрима

74. Работа с файлом через стримы. Задача посчитать длину каждой строки в файле
    Files.lines(Paths.get("123.txt")).map(String::length).forEach(System.out::println); // .lines() возвращает стрим Стрингов

75. Работа со строками через стрим. Задача посчитать количество уникальных слов в строке.

76. .limit(n) оставляет n первых элементов стрима, .skip(n) пропускает n первых элементов и оставляет оставшиеся

///////////////////////////lesson 9 Reflection API

77. Начальной точкой работы с рефлешн api является получение ссылки на объект Class. Существует 3 способа получить объект типа Class:
      Class stringClass1 = "Java".getClass();
      Class stringClass2 = String.class;
      Class stringClass3 = Class.forName("java.lang.String");

78. Class.getDeclaredMethods() возвращает массив всех методов объявленных в классе (кроме унаследованных)

79. Class.getMethods() возвращает массив всех публичных методы объявленных в классе (включая унаследованные)

80. Вызвать метод через рефлекшен можно так: method[0].invoke(cat), где Cat cat = new Cat() - конкретный объект метод которого вызывается, method[0] метод возвращенный через .getDeclaredMethods() или .getMethods() т.е. элемент массива методов Класса;

81.   Получение модификаторов
       int mod = methods[0].getModifiers(); // methods[0] получили через Class.getDeclaredMethods()
       System.out.println("is static: " + Modifier.isStatic(mod));
       System.out.println("is final: " + Modifier.isFinal(mod));
       System.out.println("is private: " + Modifier.isPrivate(mod));
       System.out.println("is public: " + Modifier.isPublic(mod));

82. Получение массива полей  Field[] fields = catClass.getDeclaredFields();

83. Все операции с полями аналогчны операциям с методами.

84. Создание объектов возмжно через (Class) Class.newInstance(), напр.
    Cat cat2 = (Cat) catClass.newInstance(); // создание объекта у которого есть дефолтный конструктор (или без параметров)

85. Если необходимо создать объект у которого конструктор принимает параметры, сделать это можно передав в .getConstructor() и .newInstace() необходимые парметры.
        Cat cat3  = (Cat) catClass.getConstructor(int.class, int.class, int.class, int.class)
                .newInstance(20, 300, 40, 50); // вызывается конструктор с 4-мя параметрами.
        System.out.println(cat3);

86. За загрузку классов в java отвечают ClassLoader'ы, например
ClassLoader classLoader = new URLClassLoader(new URL[] {new File("C:\\Users\\Alpha\\Documents\\java").toURL()}); // загрузка класса находящегося в папке C:\Users\Alpha\Documents\java

87. После загрузки класса с ним можно начинать работать:
        ClassLoader classLoader = new URLClassLoader(new URL[] {new File("C:\\Users\\Alpha\\Documents\\java").toURL()}); // загружаем классы находящиеся по указанному пути
        Class humanClass = classLoader.loadClass("Human"); // получаем ссылку на объект Class класса Human
        Object humanObject = humanClass.getConstructor(String.class, int.class).newInstance("Bob", 30); // создаем объект класса Human и ссылаем его на Object
        Method[] method = humanObject.getClass().getDeclaredMethods(); // получаем методы у класса Human
        method[0].invoke(humanObject); // вызываем метод у Human

88. Аннотация выглядит следующим образом:

    @Retention(RetentionPolicy.RUNTIME) // Аннотацию можно использовать в runtime
    @Target(ElementType.METHOD) // В качестве таргета - метод.
    public @interface MyAnnotation {
        int priority() default 5; // в аннотацию можно подшивать доплнительную информацию в виде параметров.
    }

89. Вместо priority в качестве дополнительного параметра можно указывть timeout, времы выполнения и многое другое

90. Обратиться к параметрам аннотации можно чере конструкцию:
    classMember.getAnnotation(MyAnnotation.class).priority(), где classMember - поле или метод полученные через рефлекшн, priority() - параметр

91. jdbc представляет собой набор интерфейсов для взаимодействия с базами данных sql

92. Алгоритм работы с БД через идеа следующий:
    - подключаем jdbc драйвер -> pom.xml -> <dependencies> <dependency> копируем код с рипозитория мавена sqlite-jdbc
    - создаем поля для конекшена и стейтмента:
        - Connection connection;
        - Statement statement;
    - создаем два метода .connect() .disconnect() в которых прописываем логику.
    - в .connect() в блоке try
        - Class.forName("org.sqlite.JDBC"); // загружаем драйвер
        - connection = DriverManager.getConnection("jdbc:sqlite:main.db"); // создаем коннекшн
        - statement = connection.createStatement(); // создаем стейтмент
        - в catch ловим ClassNotFoundException | SQLException e
    - в .disconnect()
        - закрываем в обратном порядке, сначала стейтмент statement.close()
        - connection.close

93. В методе main() вызываем .connect()

94. Обращение к базе происходит через стейтмент после коннекта к базе, напр: statement.executeUpdate("комманда SQL")

95. .executeUpdate("комманда SQL") возвращает интовое значение соответствующее количеству строк подвергшихся изменению

96. В ответ на запрос в любом случае возвращается таблица, котрая запсывается в ResultSet

97. ResultSet.next() возвращает true если запись в таблице содержит значения, либо false если значений нет. Т.е. пока rs.next() == true, в таблице есть значения, как только rs.next() == false значит значений нет.

98. Алгоритм печати таблицы полученной в ResultSet:
      try(ResultSet rs = statement.executeQuery("SELECT * from students")) {
          while(rs.next()) {
             System.out.println(rs.getInt(1) + " " + rs.getString("name") + " " + rs.getInt(3));
            }
                }
        } catch (SQLException e) {
            e.printStackTrace();
        } // в getInt() , getString() можно передавать либо имя столбца, либо его номер.
       }

99. Алгоритм вставки в таблицу
        static void tableInsert() {
            try {
                statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob4', 100);");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

100. Алгоритм обновления данных в таблице
        static void tableUpdate() {
            // обновление данных в таблице
            try {
                statement.executeUpdate("UPDATE students SET  score = 200 WHERE id = 1");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

101. Алгоритм очистки таблицы
        static void tableClear() {
             try {
                 statement.executeUpdate("DELETE FROM students");
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }


102. Алгоритм удаления записи из таблицы
         static void tableDelete() {
             try {
                 statement.executeUpdate("DELETE FROM students WHERE id = 4");
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }

103. Работа с PreparedStatement
    - У класса задается поле private static PreparedStatement preparedStatement;
    - в методе .connect() создается шаблон:
    preparedStatement = connection.prepareStatement("INSERT INTO students (name, score) VALUES (?,?); ");
    - в методе .main() делается обращение к preparedStatement:
        preparedStatement.setString(1, "Bob"+ i); // 1- индекс параметра
        preparedStatement.setInt(2, 50); // 2- индекс параметра
        preparedStatement.executeUpdate(); // запуск на выполнение

104. При работе с PreparedStatement в случае если точно не известен тип значения в ячейке, то вместо setInt(), setString() можно указывать setObject();

105. Для ускорения скорости транзакций можно отключать автокомит
       connection.setAutoCommit(false); // отключили вызов комита для каждой транзакции
            for(int i=0; i<10000; i++) {
               preparedStatement.setString(1, "Bob"+ i);
               preparedStatement.setInt(2, 50);
               preparedStatement.executeUpdate();
            }
       connection.commit(); сделали коммит для всех запросов
    + в увеличении скорости
    - возможная потеря данных, если произойдет сбой, на 9999 транзакции никакие данные в таблицу не запишутся.

106. Также транзакции можно предварительно аккумулировать с помощью .addBatch() и затем комитить сразу все пачку запросов
        static void preparedStatementBatchEx() {
            try {
                for(int i=0; i<10000; i++) {
                    preparedStatement.setString(1, "Bob"+ i);
                    preparedStatement.setInt(2, 50);
                    preparedStatement.addBatch(); // добавляем в batch
                }
                preparedStatement.executeBatch(); // выполняем batch
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

107. В код можно вставлять точки сохранения после выплнения запроса и делать к ним откаты, например:
       statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob1', 1000);");
        Savepoint sp1 = connection.setSavepoint(); // точка сохранения
        statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob2', 1000);");
        connection.rollback(sp1); // откат к sp1

108. Если необходимо чтобы класс попал в таблицу его помечают соответствующей аннотацией. Например нужно записать объект класса Студент в таблицу базы данных "students" тогда этот класс помечается аннотацией @Students

////////////////////////Lesson 10 PostgreSQL//////////////////////
109. CREATE TABLE students (id serial, name text, score int); // создание таблицы в терминале

110. Схема это что-то наподобие пространства имен. В одной схеме можно разместить несколько таблиц. Чтобы обратиться к конкретной таблице в схеме нужно указать: схема.таблица

111. Для выбора схемы по умолчанию нужно укзать в терминале: SET search_path to schema;

112. DROP TABLE table_name // удалить таблицу table_name

113. INSERT INTO student (value1, value2) VALUES (val1, val2); // вставка данных в таблицу

114. INSERT INTO students (name, score) VALUES ('Bob3', 150) RETURNING *; // покзажет в терминале строку которая была внесена в таблицу

115. Можно не писать для каждой новой строки INSERT а укзать все в дном запросе:
INSERT INTO students (name, score) VALUES ('Bob3', 150), ('Bob4',40), ('Bob5', 60);

116. SELECT id, name FROM students WHERE score > 50; // можно выбирать какие столбцы выводить в зависимости от условия
     id | name
    ----+------
      3 | Bob3
      4 | Bob3
      6 | Bob5

117. Выводить можно в определенном порядке:
    SELECT id, name FROM students WHERE score > 50 ORDER BY id DESC [ASC - по возрастанию];

118. Внесение изменений в таблиц:
UPDATE students SET score = 80 WHERE name = 'Bob3';

119. Удаление определенной записи:
DELETE FROM students WHERE id = 3;

120. Удаление всех записей в таблице:
TRUNCATE students;

121. Вывести все записи у который в поле name значение начинается на Bob:
SELECT * FROM students WHERE name LIKE 'Bob%';

122. Вывести все записи у который в поле name значение из 4 символов, второй 'o':
SELECT * FROM students WHERE name LIKE '_o__';

123. Вывести все записи в диапазоне значений
SELECT * FROM students WHERE score BETWEEN 40 AND 50;

124. Вывести поле вычесленое на основе данных другого поля под новым названием:
    SELECT name, score, score/5 AS another_score FROM students;

125. Вывести записи с уникальными значениями поля name:
    SELECT distinct name FROM students;

126. Показать первые три записи:
    SELECT * FROM students LIMIT 3;

127. Вывод поля в зависимости от условия:
SELECT name, score, CASE WHEN score > 79 THEN 'SUPER' WHEN score BETWEEN 60 AND 78 THEN 'GOOD' ELSE 'BAD' END AS result FROM students;
 name | score | result
------+-------+--------
 Bob1 |    50 | BAD
 Bob2 |    50 | BAD
 Bob4 |    40 | BAD
 Bob5 |    60 | GOOD
 Bob3 |    80 | SUPER
 Jhon |    80 | SUPER

128. команда терминала - вывод данных о таблице: \d students

129. Создать таблицу в которой поле mark принимате значения в диапазоне от 2 до 5:
CREATE TABLE progress (id serial, subject text, mark int CHECK (mark >=2 AND mark <=5));

130. Создание таблице с уникальными записями в стобце:
    CREATE TABLE demo (subject text UNIQUE, mark int, etc...) // в столбце subject будут только уникальыне значения, существует альтернативная запись:
    CREATE TABLE demo (subject text , mark int, CONSTRAINT unique_subject UNIQUE (subject));

131. Задание PRIMARY KEY:
    CREATE TABLE demo (id serial, name TEXT, PRIMARY KEY (id));

132. Добавление колонки в таблицу:
    ALTER TABLE progress ADD COLUMN student_id integer;

133. Добавление primary key в таблицу:
    ALTER TABLE students ADD PRIMARY KEY (id);

134. Добавление foreign key в таблицу:
    ALTER TABLE progress ADD FOREIGN KEY (student_id) REFERENCES students (id);

135. Удаление колонки из таблицы:
    ALTER TABLE progress DROP COLUMN id;

136. Вставка значений в таблицу с указанием foreign key:
    INSERT INTO progress (subject, mark, student_id) VALUES ('Math', 5, 7);, где 7 значение id таблице students

137. По-сути foreign key - это колонка с сылкой на колонку из основной таблицы, соответствено значения у них одинаковы.

138. Удаление foreign key:
    ALTER TABLE progress DROP CONSTRAINT progress_student_id_fkey;

139. При удалениии записи из основной таблицы, можно указать следующией опции в отношении связанных таблиц:
    ON DELETE CASCADE; // удалить связанные записи
    ON DELETE RESTRICT; // запретить удаление, если имеются связанные записи. Т.е. сначал придется удалить записи из связанных таблиц, а затем из основной
    ON DELETE NO ACTION
    ON DELETE SET NULL //
    ON DELETE SET DEFAULT // присвоить дефолтное значение.

140. Добавление проверки на столбец
     ALTER TABLE table_name ADD CHECK (score > 100);

141. Удалить ограничение по имени:
    ALTER TABLE students DROP CONSTRAINT students_score_check;

142. Изменить тип данных в столбце:
    ALTER TABLE students ALTER COLUMN name SET DATA TYPE VARCHAR;

143. Если тип данных менятся например int на TEXT используется CASE:
     ALTER TABLE students ALTER COLUMN mark SET DATA TYPE VARCHAR USING (CASE WHEN mark = 5 THEN 'A' WHEN mark = 4 THEN 'B' ELSE 0 END);

144. Часто испльзуемые запросы можно записывать (типа макроса):
    CREATE VIEW my_view AS SELECT score, name, id FROM students WHERE score > 50 ORDER BY id ASC;
    вызов: SELECT * FROM my_view;

145. Удаление записанного VIEW:
    DROP VIEW my_view;

146. Транзации должны обладать следующим набором свойств:
    - атомарность т.е. транзакция выполняется либо полностью либо не выполняется вообще
    - согласованность т.е. в случае выполнения транзакии база данных должна перейти из одного согласованого состояния в другое
    - изолированность т.е. если параллельно происходят несколько транзакции они должны минимальнов воздействовать друг на друга
    - долговечность т.е. если транзакция выполнилась, то данные в базе сохраняются и не могут быть потеряны по пути

147. При работе с транзакциями существует 4 уровня изоляции:
    - Read uncommitted допускается чтение незакомиченных данных
    -  Read committed допускается чтение только закомиченных данных
    -  Repeatable read транзакция не
    - Serialazable результат последоватльного выполнения транзакций == результату парралельного выполнения

148. Блокировка всей таблицы во время выполнения одной транзакции (для других транзакций)
    LOCK TABLE students IN ACCESS EXCLUSIVE MODE;

149. Блокировка конкретной записи в таблице:
    SELECT * FROM students WHERE id = 5 FOR UPDATE; // блокировка записи с id = 5;

150. Создание индекса с именем name_idx в таблице students по колонке name
    CREATE INDEX name_idx ON students (name);

151. Механизм подключения hybernate и базы данных:
    - в pom.xml в dependency подключаем hibernate-core
    - в pom.xml в dependency подключаем драйвер базы данных, напр постгре



/////////////////ВОПРОСЫ//////////////////
1. Когда инициализируются статические поля и методы, когда в память загружается класс?
2. Как можно вызвать нестатический метод из статического?
3. Где храниться объект и ссылка на него?
4. Что попадает в стэк при начале выполнения программы?
5. Может ли ссылка на объект храниться в куче?
6. Можно ли пользоваться неинициализированной локальной переменной?
7. Какие переменные инициализируются по умолчанию?
8. Что необходимо сделать, чтобы поля родителя перешли в наследника?
9. Где могут находится абстрактные методы?
10. Какие методя объекта можно вызвать если он ссылается на ссылку родителя Animal animal = new Dog();?
11. Можно объект родителя сослать на ссылку наследника Cat cat = new Animal();? Почему так?
12. Можно ли сослать объекты на ссылку интерфейсного типа, если они имплементируют этот интерфейс Flyable Duck = new Duck();?
13. Что нужно сделать чтобы обратиться к методу объекта имплементирующему несколько интрефейсов?
14. Для чего нужны дефолтне методы?
15. Допустимы ли в названиямх пакетов большие буквы?
16. В какой строке стэектрейс находится место указывающее на ошибку? Что находится в последней строке?
17. В чем смысл пробрасывания исключенрия наверх?
18. Что означает запись <T extends superclass> ?
19. Может ли использоваться дженерик класса статическим членом этого класса? Почему?
20. Можно ли в статическом методе использовать собственные дженерики?
21. Можно ли созадавать обобщеные классы исключений, почему?
22. С какими типами данных работает ArrayList, как организована рабта коллекций с примитивными типами данных?
23. Выводы из ДЗ3
24. Можно ли создавать обобщенные массивы? Т[] array = new T[10];
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
35. Что такое рехэшинг мапы?
36. Что такое Loadfactor в хэшмапе?
37. Что делает метод HashMap.getOrDefault(key, DefaultValue) ?
38. В чем различия между HashMap<>, LinkedHashMap<>,  TreeMap<> ?
39. Какми классами реализуетсяИнтерфейс Set? В чем между ними различие?
40. В чем особенность Set?
41. В чем различие между HashTable и HashMap?
42. В чем различие между Vector и  ArrayList?
43. Чего нельзя делать при обходе коллекции через foreach?
44. Станадртный алгоритм обхода и изменения коллекции.
45. Для обхода каких коллекций подходит Iterator, что насчет HashMap?
46. Для чего предназначен listIterator?
47. Простой способ обхода мапы?
48. До каких пор будет работать поток демеон, когда он прекратит работу?
49. Что делает метод .interupt() у потока?
50. Что испльзуется в качестве монитора в synchronized методе?
51. В чем смысл обработки InteruptedException?
52. Можно ли синхронизировать не весь, а часть метода?
53. Что выступает в качестве монитора для статического метода?
54. Что происходит когда синхронизированый метод получает управление?
55. Какое условие должно соблюдаться при передаче переменной во внутренний (анонимный) класс?
56. Какие  3 вида ThreadPool существует?
57. Что будут делать потоки которым нужно попасть в синхронизованный блок, который уже занят?
58. Почему для синхранизации Hashtable лучше не использовать, что лучше использовать?
59. В чем преимущество ConcurrentHashTable?
60. Как получить синхронизированную коллекцию из обычной?
61. Меняется ли исходная коллекция при работе стрима?
62. Как получить коллекцию (лист) заполненный значениями?
63. Для чего служит метод .map() ?
64. Примеры использовария .map() ?
65. Для чего служить метод limit(n) ?
66. Что делает метод  .distinct() ?
67. Примеры использовария .match() ?
68. Что делает .findAny() ?
69. Что можно делать с лямбдами и ссылками на метод и куда передавать?
70. Что делает .reduce() ?
71.  Какие специфические виды стримов существуют?
72. Для чего служит .mapToInt() ?
73. ДЛя чего служит .skip(n) ?
74. Как посчитать длину каждой строки в файле?
75. Как посчитать количество уникальных слов в строке?
76. Для чего служат методы .limit(n) .skip(n) ?
77. С чего начинается работа с рефлекшн api? Три способа получить ссылку на Class?
78. Что возвращает Class.getDeclaredMethods() ?
79. Что возвращает Class.getMethods() ?
80. Как вызвать метод у объекта через рефлекшн?
81. Как плучить модификаторы членов у объекта?
82. Как получить массив полей объекта?
83. В чем отличие операций с полями от операций с методами?
84. Как создать объект через рефлектион?
85. Как создать объект через конструктор с парметрами?
86. Как загрузить класс не являющийся частью проекта?
87. Алгоритм работы с загруженным классом?
88. Из чего состоит аннотация?
89. Что можно указать в качестве параметра у аннотации?
90. Как обратиться к параметру аннотации?
91. Что   представляет собой jdbc?
92. Алгоритм подключеия БД в идеа?
93. Что вызывается в .main() для подключения?
94. Через что происходит обращение и работа с БД?
95. Что возвращает .executeUpdate("комманда SQL") ?
96. Что записывает в ResultSet?
97. Что возвращает ResultSet.next()? До какого момента можно обходить БД?
98. Как вывести таблицу из ResultSet?
99. Алгоритм вставки в таблицу?
100. Алгоритм обновления записи в таблице?
101. Алгоритм очистки таблицы?
102. Алгоритм удаления записи из таблицы?
103. Что такое PreparedStatement, как с ним работать?
104. Что можно указать в setInt(), setString() если неизвестен тип данных в ячейке?
105. Что можно сделать для ускорения скорости транзакций?
106. Для чего и как используется .addBatch()?
107. Как создать точку сохранения и сделать откат?
108. Что нужно сделать с классом для записи в таблицу?
109. Команда создания таблицы?
110. Что такое схема, как обратиться к таблице в схеме?
111. Как выбрать текущую схему?
112. Как удалить таблицу?
113. Как всативть данные в таблицу?
114. Что добавляется в конце запроса для вывода результата его выполнения?
115. Как записать несколько строк в таблице в одном запросе?
116. Как вывести определенные столбцы в зависимости от условия?
117. Как задать порядок вывода данных из таблицы?
118. Как изменить запись в таблице?
119. Как удалить определенную запись в таблице?
120. Как удалить все записи в таблице?
121. Как выбрать записи из таблицы по маске (поле начинается на..)?
122. Как выбрать записи из таблицы по маске (поле содержит)?
123. Как вывести записи в диапазоне значений?
124. Как вывести в новый столбец значние вычесленное на основе другого поля?
125. Как вывести уникальные записи по значению определенного поля?
126. Как оганичить количество выводимых записей?
127. Как указать условие вывода данных в новый столбец?
128. Команда терминала для вывода данных о таблице?
129. Создать таблицу в которой для поля задется диапазон возможных значений.
130. Создание таблице с уникальными записями в стобце?
131. Задание PRIMARY KEY?
132. Добавление колонки в таблицу?
133. Добавление primary key в таблицу?
134. Добавление foreign key в таблицу?
135. Удаление колонки из таблицы?
136. Вставка значений в таблицу с указанием foreign key?
137. Что такое fk?
138. Удаление foreign key?
139.
140. Добавление проверки на столбец?
141. Удалить ограничение по имени?
142.
