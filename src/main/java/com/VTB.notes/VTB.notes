
1. Вся статика инициализируется когда класс загружается в память, класс загружается в память когда к нему впервые обращаются (это может быть обращение к статическому полю, методу, создание объекта)

2. Вызвать нестататический метод из статического можно только через экземпляр класса экземпляр.nonStaticMethod();

3. Объект храниться в куче, ссылка на него храниться в стэке.

4. Когда программа начинает выполняться в стек попдают вызовы методов и локальные переменные

5. Ссылки на объекты храняться в стеке, но если у объекта есть ссылка на другой объект, то такая ссылка будет храниться вместе с объектом в куче.

6. Локальной переменной нельзя пользоваться пока она не инициализирована, т.е локальные переменные по умолчанию не инициализируются.

7. По умолчанию инициализируются поля объектов.

8. Если необходимо чтобы поля родителя перешли к наследникам у них убирается модификатор private.

9. Абстрактные методы могут находится только внутри абстрактного класса.

10. Если объект наследник ссылается на родительскую ссылку:
    Animal animal = new Dog("Bobik", "White", 2);
то по такой ссылке напрямую можно вызывать только методы родителя:
    animal.helloFromAnimal();
    animal.helloFromDog(); // так не работает, потому что теоретически на Animal можно сослать и Dog и Cat и Hamster etc и тогда может возникнуть возможность у хомяка вызвать метод собаки.
чтобы вызвать метод наследника, нужно сделать принудительный каст, явно указав что по ссылке Animal находится Dog
    ((Dog)animal).helloFromDog();

11. Положить в ссылку наследника объект родителя нельзя:
    Cat cat = new Animal(); // так не работает, потому что родитель не знает какие методы есть у наследника.

12. Если несколько классов имплементят один интерфейс их можно положить в переменную этого интерфейса, даже если они сильно отличаются. Например, Interface Flyable, на переменную типа Flyable можно ссылать объекты Duck, Airplane, Fly etc... Flyable fly = new Fly(), Flyable Duck = new Duck().

13. Если в интерфейсную переменную кладется объет релализующий несколько интерфейсов, то для вызовва метода одного из интерфейса, необходимо будет сделать каст к этому интерфейсу, (Swimable) duck.swim(), где swim - метод интерфейса Swimable.

14. Внутренние вложенные классы служать для организации кода, чтобы не выносить наружу то, что требуется лишь контексте внешнего класса. Например класс шахматная клетка имее смысл только в контексте класса шахматная доска, поэтому логично создать внутренний класс клетка внутри класса шахматная доска.

15. Внутренний аннонимный класс имеет название класса в котором он был образован с добаление $порядковыйНомер, например SomeClass$1

14. Смысл дефолтных методов в том, что дефолтные методы могут реализовываться всеми классами имплиментирующими интерфейс, при этом если в каком то классе нужно изменить логику дефолтного метода это не отразится на остальных классах реализующих данный интерфейс.

15. В назаваниях пакетов большие буквы недопустимы.

16. В распечатке stacktrace место, которое вызвало ошибку печатся во второй строке, например:
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at com.lesson3.MainApp.a(MainApp.java:14) // 3. здесь возникла ошибка
    	at com.lesson3.MainApp.b(MainApp.java:9) // 2. потом был вызов сюда
    	at com.lesson3.MainApp.main(MainApp.java:5) // 1.  путь к ошибке начался отсюда

17. Смысл пробрасывания исключения наверх не в том, чтобы загасить его в самом начале (в месте откуда оно вылетело), а в том чтобы обработать его на том этапе где это будет максимально полезно с точки зрения логики работы программы

////////////////////Lesson 4. Generis, Collections//////////////////////

18. Запись <T extends superclass> означает, что параметр Т может быть заменен только суперклассом или его подкассами

19. Никакой статический член не может использовать тип параметра, объявленный в его классе:

public class WrongGenericClass<T> {
   static Т data; // Неверно, нельзя создать статические переменные типа Т

   static Т getData() {
     return  data; }  // Неверно, ни один статический метод не может использовать Т
}

20. Нельзя объявить статические члены, использующие обобщённый тип. Но можно объявлять
    обобщённые статические методы, определяющие их собственные параметры типа.

21. Обобщённый класс не может расширять класс Throwable. Значит, создать обобщённые классы
    исключений невозможно.

22. Класс ArrayList, как и все коллекции в целом, может работать только с ссылочными типами
    данных. Для хранения примитивов необходимо использовать “обертки”: Byte, Short, Integer, Long,
    Float, Double, Character, Boolean.

23. Выводы по ДЗ3: прежде чем проводить какие-то вычисления необходимо проверить корректность входных данных, иначе к концу вычеслений может выясниться, что данные не верны и программа упадет затратив перед этим ресурсы.

24. Внутри обобщенного класса нельзя создавать объекты обобщеного типа:
void doSomething() {
   T obj = new T();
 }
 также нельзя создавать дженирализованные массивы: Т[] array = new T[10]; // так нельзя

25. В  дженериках наследование не работает, те. нельзя написать : GenBox<Number> gbx = new GenBox<Integer>(123); в правой части выражения должен быть тот же тип, что и в левой GenBox<Integer> gbx = new GenBox<Integer>(123);

26. public static void doSomething(GenBox<? super Number>) {} означает что метод принимает GenBox параметризованый Number или его родителями.

27. Существуют тажке параметризованные интерфейсы, например Comparable<>, его удобно применять при сравненни классов, например
    Class Box implement Comparable<Box> {

    @override
    comareTo(Box o) {
        return this.size - o.size;
    }
    }

28. Метод copy(List<? super T> consumer, List<? extends T> producer) PECS. Допустим consumer - лист животных, а producer - лист котов. Котов можно скопировать в лист животных, а животных в лист котов нельзя.

29. Varargs может быть только один, и должен стоять последним в списке аргументов.

////////////////////////COLLECTIONS//////////////////////
30. Начальная емкость ArrayList = 10 элементам и по мерер расширения увеличивается в 1.5 раза

31. Пример удалить все буквы "В" в листе: while(list.remove("B");

32. При создании новых классов если предполагается их сравнение у них нужно переопределить методы equals(), hashcode();

33. Отсортировать коллекцию можно двумя способоми:
    1. вызывать у коллекции метод sort(Comparator<? super T> c)
    2. вызвать у утильного класса Collections метод sort(Collection c, Comparator <? super T> c) переадав в него коллекцию и компаратор, пример:

    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "BBB", "CC", "GGGGG", "YYYY"));
        list.sort((o1, o2) -> o1.length() - o2.length()); // Способ 1
        Collections.sort(list, (o1, o2) -> o1.length() - o2.length()); // Способ 2

        System.out.println(list);
    }

34. Поиск элемента по индексу в LinkedList происходит путем прохода по всем элементам начиная с первого (или последнего) и подсчета количества переходов. Поэтому поиск по индексу здесь дольше чем в ArrayList

/////////////////////Lesson5 07.04.2021//////////////////////
35. Рехэшинг пересчет хэшей элементов в хэшмэп при увлеличении ее емкости

36. Loadfactor в хэшмапе указывает на то насколько должна быть заполнена хэшмэп, чтобы начачть увеличиваться (увеличение происходит в 2 раза)

37. метод HashMap.getOrDefault(key, DefaultValue), если ключ существует возвращает содержащееся по нему значение, иначе возвращет DefaultValue

38. HashMap<> не гарантирует порядко добавления/извлечения, если необходим порядок нужн использовать LinkedHashMap<>. TreeMap<> хранить значения в упорядоченном по ключу виде.

39. Интерфейс Set реализуется классами ashSet<> - порядок добавления/извлечения не гарантируется, LinkedHashSet - порядок гарантируется, TreeSet - хранит значения в отсортированом виде.

40. Особенность Set - в нем храняться только уникальные значения.

41. HashMap позволяет использовать null в  качестве ключей и значений, HashTable - не позволяет. Еще отличие HashMap не synchronized, HashTable synchronized

42. Vector и  ArrayList практически то же самое, различие Vector- synchronized, ArrayList - не synchronized

43. В момомент обхода коллекции (напр. foreach) ее нельзя модифицировать (удалалять, добавлять элементы)

44. Стандартный алгоритм обхода и изменения коллекции:
         List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "A"));
         Iterator<String> iterator = list.iterator(); // 1. Создаем итератор
            while(iterator.hasNext()) { // 2. Обходим коллекцию пока в ней есть следующее значение
              if(iterator.next().equals("A")) { // 3. Если условие выполняется
                 iterator.remove(); // 4. Производим действие
                }

45.  Iterator подходит для обхода Set и  List, для обхода HashMap Iterator не подходит. Но это ограничение можно обойти если применить итератор к EntrySet мапы. - map.entrySet().iterator();

46. Для обхода листов предусмотрен более специализированный listIterator() у которого есть большее количество методов для работы с листами. list.listIterator().nextIndex();

47. Простой способ вывести все пары ключ:значение в мапе:
    data.forEach((x,y)-> System.out.println(x + ": " + y));

/////////////////Lesson6//////////////////////
48. Поток демон будет работать пока работает хотя бы один обычный Поток. Как только все обычные Потоки завершаться демон тоже завершается.

49. Для остановки потока испльзуется метод thread.interupt(), затем в безопасном месте кода делается проверка на thread.isinterupted(), если возвращается true делается выход из потока.

50. При испольовании synchronized при вызове метода в качестве монитора испльзуется this, т.е. объект на котором был вызван метод.

51. Смысл обработки InteruptedException в том, что кто-то может попытаться оставновить поток который в данный момент недоступен (спит) в этом случае нужно предпринять какие то действия.

52. Синхронизированным можно делать не весь, а часть метода,

public class Test1 {
    Object monitor = new Object();

    public static void main(String[] args) {
        Test1 monitor = new Test1();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();

    }

    public void  method() {
        // non synchronized block --> сюда зайдут три потока одновременно !!!!!!!!!!!!!!
        System.out.println(Thread.currentThread().getName() + " non sync starts");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // synchronized block --> а сюда только по очереди !!!!!!!!!!!!!!
        synchronized (monitor) {
            System.out.println(Thread.currentThread().getName() + " sync starts");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

53. Если метод статический, то в качестве монитора выступает сам класс и доступ к такому методу одномоментно имеет только один поток.

54. Как только синхронизированный метод любого объекта получает управление, объект блокируется и ни один синхронизированный метод этого объекта не может быть вызван другим потоком. Скорее всего так потому, что объект блокируется по this, если в synchronized передавать разные объекты, то можно вызывать синхронизованные методы и блоки кода если они лочаться разными мониторами.

55. Если во внутренний (анонимный) класс передается извне какая-то переменная, то эта переменаня должна быть либо final, либо effectivly final

56. Существует 3 вида ThreadPool: 1. FixedTreadPool(4) - на определенной количество потоков, SingleThreadPool - на 1 поток, CachedThreadPool - на неограниченное количество потоков.

57. Если синхронизованный блок занят каким то потоком, то остальные потоки, которым тоже нужно попасть в этот блок, будут ждать (и ничего не делать) пока освободиться этот блок.

58. Hashtable лучше не использовать, потому что в качестве монитора выступает сама таблица соответственно она блокируется целиком. В этом случае лучше брать concurrentHashMap/

59. Преимущество CuncurrentHashTable в том, что при записи блокируется только та ячейка в которую проводится запись остальные ячейки остаются незаблокированными.

60. Для получения синхронизированнной коллекции из обычной можно использовать методы класса Collections
     Collections.synchronizedList()
     Collections.synchronizedMap()
     Collections.synchronizedSet()

     //////////////////////LESSON 8 Stream API////////////////////////////

61. При работе стрима исходная коллекция не меняется.

62. Простой способ получить заполненный лист List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
передать в конструктор лист.

63. Метод .map() служит для преобразования одних типов объектов в другой тип, например преобразование стрингов в интеджер
  Stream.of("AA", "D", "CCC", "NN").map(s -> s.length()).forEach(System.out::println); // 2 1 3 2
  или могут проводиться операции над одними типами например интеджер в интеджер:
    Stream.of(1, 2, 3, 4).map(s -> s + 1).forEach(System.out::println); // 2 3 4 5

64. Ссылка на метод примеры код в файле Test1.java:
 Stream.of("aa", "bb").map(String::length).forEach(System.out::println); // для каждого объекта типа String в потоке вызвать метод .length()
 Stream.of("aa", "bb").map(s -> s.length()).forEach(System.out::println); // то же самое

 Stream.of("Bob", "Mike", "Jhon").map(User::new).forEach(User::getName); // для каждого объекта типа User в потоке вызвать метод new() т.е. конструктор, а затем метод .getName();
 Stream.of("Bob", "Mike", "Jhon").map(s-> new User(s)).forEach(s -> s.getName()); // то же самое

65. Метод limit(n) оставляет в стриме n первых объектов.

66. Метод .distinct() оставляет в стриме только уникальные элементы:
        Arrays.asList(1,2,3,4,1,2,2).stream().distinct().forEach(System.out::println); // 1 2 3 4
        Arrays.asList("Jhon", "Mike", "Jhon").stream().distinct().forEach(System.out::println); // Jhon Mike

67. //math example
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().allMatch(s -> s > 0)); // true. Все элементы больше 0
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().anyMatch(s -> s > 10)); // false. Хоть один элмент стрима больше 10
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().noneMatch(s -> s == 7)); // false. Не один элемент не равен 7





/////////////////ВОПРОСЫ//////////////////
1. Когда инициализируются статические поля и методы, когда в память загружается класс?
2. Как можно вызвать нестатический метод из статического?
3. Где храниться объект и ссылка на него?
4. Что попадает в стэк при начале выполнения программы?
5. Может ли ссылка на объект храниться в куче?
6. Можно ли пользоваться неинициализированной локальной переменной?
7. Какие переменные инициализируются по умолчанию?
8. Что необходимо сделать, чтобы поля родителя перешли в наследника?
9. Где могут находится абстрактные методы?
10. Какие методя объекта можно вызвать если он ссылается на ссылку родителя Animal animal = new Dog();?
11. Можно объект родителя сослать на ссылку наследника Cat cat = new Animal();? Почему так?
12. Можно ли сослать объекты на ссылку интерфейсного типа, если они имплементируют этот интерфейс Flyable Duck = new Duck();?
13. Что нужно сделать чтобы обратиться к методу объекта имплементирующему несколько интрефейсов?
14. Для чего нужны дефолтне методы?
15. Допустимы ли в названиямх пакетов большие буквы?
16. В какой строке стэектрейс находится место указывающее на ошибку? Что находится в последней строке?
17. В чем смысл пробрасывания исключенрия наверх?
18. Что означает запись <T extends superclass> ?
19. Может ли использоваться дженерик класса статическим членом этого класса? Почему?
20. Можно ли в статическом методе использовать собственные дженерики?
21. Можно ли созадавать обобщеные классы исключений, почему?
22. С какими типами данных работает ArrayList, как организована рабта коллекций с примитивными типами данных?
23. Выводы из ДЗ3
24. Можно ли создавать обобщенные массивы? Т[] array = new T[10];
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
35. Что такое рехэшинг мапы?
36. Что такое Loadfactor в хэшмапе?
37. Что делает метод HashMap.getOrDefault(key, DefaultValue) ?
38. В чем различия между HashMap<>, LinkedHashMap<>,  TreeMap<> ?
39. Какми классами реализуетсяИнтерфейс Set? В чем между ними различие?
40. В чем особенность Set?
41. В чем различие между HashTable и HashMap?
42. В чем различие между Vector и  ArrayList?
43. Чего нельзя делать при обходе коллекции через foreach?
44. Станадртный алгоритм обхода и изменения коллекции.
45. Для обхода каких коллекций подходит Iterator, что насчет HashMap?
46. Для чего предназначен listIterator?
47. Простой способ обхода мапы?
48. До каких пор будет работать поток демеон, когда он прекратит работу?
49. Что делает метод .interupt() у потока?
50. Что испльзуется в качестве монитора в synchronized методе?
51. В чем смысл обработки InteruptedException?
52. Можно ли синхронизировать не весь, а часть метода?
53. Что выступает в качестве монитора для статического метода?
54. Что происходит когда синхронизированый метод получает управление?
55. Какое условие должно соблюдаться при передаче переменной во внутренний (анонимный) класс?
56. Какие  3 вида ThreadPool существует?
57. Что будут делать потоки которым нужно попасть в синхронизованный блок, который уже занят?
58. Почему для синхранизации Hashtable лучше не использовать, что лучше использовать?
59. В чем преимущество CuncurrentHashTable?
60. Как получить синхронизированную коллекцию из обычной?
61. Меняется ли исходная коллекция при работе стрима?
62. Как получить коллекцию (лист) заполненный значениями?
63. Для чего служит метод .map() ?
64. Примеры использовария .map() ?
65. Для чего служить метод limit(n) ?
66. Что делает метод  .distinct() ?
67. Примеры использовария .match() ?