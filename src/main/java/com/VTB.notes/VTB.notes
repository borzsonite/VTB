
1. Вся статика инициализируется когда класс загружается в память, класс загружается в память когда к нему впервые обращаются (это может быть обращение к статическому полю, методу, создание объекта)

2. Вызвать нестататический метод из статического можно только через экземпляр класса экземпляр.nonStaticMethod();

3. Объект храниться в куче, ссылка на него храниться в стэке.

4. Когда программа начинает выполняться в стек попдают вызовы методов и локальные переменные

5. Ссылки на объекты храняться в стеке, но если у объекта есть ссылка на другой объект, то такая ссылка будет храниться вместе с объектом в куче.

6. Локальной переменной нельзя пользоваться пока она не инициализирована, т.е локальные переменные по умолчанию не инициализируются.

7. По умолчанию инициализируются поля объектов.

8. Если необходимо чтобы поля родителя перешли к наследникам у них убирается модификатор private.

9. Абстрактные методы могут находится только внутри абстрактного класса.

10. Если объект наследник ссылается на родительскую ссылку:
    Animal animal = new Dog("Bobik", "White", 2);
то по такой ссылке напрямую можно вызывать только методы родителя:
    animal.helloFromAnimal();
    animal.helloFromDog(); // так не работает, потому что теоретически на Animal можно сослать и Dog и Cat и Hamster etc и тогда может возникнуть возможность у хомяка вызвать метод собаки.
чтобы вызвать метод наследника, нужно сделать принудительный каст, явно указав что по ссылке Animal находится Dog
    ((Dog)animal).helloFromDog();

11. Положить в ссылку наследника объект родителя нельзя:
    Cat cat = new Animal(); // так не работает, потому что родитель не знает какие методы есть у наследника.

12. Если несколько классов имплементят один интерфейс их можно положить в переменную этого интерфейса, даже если они сильно отличаются. Например, Interface Flyable, на переменную типа Flyable можно ссылать объекты Duck, Airplane, Fly etc... Flyable fly = new Fly(), Flyable Duck = new Duck().

13. Если в интерфейсную переменную кладется объет релализующий несколько интерфейсов, то для вызовва метода одного из интерфейса, необходимо будет сделать каст к этому интерфейсу, (Swimable) duck.swim(), где swim - метод интерфейса Swimable.

14. Внутренние вложенные классы служать для организации кода, чтобы не выносить наружу то, что требуется лишь контексте внешнего класса. Например класс шахматная клетка имее смысл только в контексте класса шахматная доска, поэтому логично создать внутренний класс клетка внутри класса шахматная доска.

15. Внутренний аннонимный класс имеет название класса в котором он был образован с добаление $порядковыйНомер, например SomeClass$1

14. Смысл дефолтных методов в том, что дефолтные методы могут реализовываться всеми классами имплиментирующими интерфейс, при этом если в каком то классе нужно изменить логику дефолтного метода это не отразится на остальных классах реализующих данный интерфейс.

15. В назаваниях пакетов большие буквы недопустимы.

16. В распечатке stacktrace место, которое вызвало ошибку печатся во второй строке, например:
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at com.lesson3.MainApp.a(MainApp.java:14) // 3. здесь возникла ошибка
    	at com.lesson3.MainApp.b(MainApp.java:9) // 2. потом был вызов сюда
    	at com.lesson3.MainApp.main(MainApp.java:5) // 1.  путь к ошибке начался отсюда

17. Смысл пробрасывания исключения наверх не в том, чтобы загасить его в самом начале (в месте откуда оно вылетело), а в том чтобы обработать его на том этапе где это будет максимально полезно с точки зрения логики работы программы

////////////////////Lesson 4. Generis, Collections//////////////////////

18. Запись <T extends superclass> означает, что параметр Т может быть заменен только суперклассом или его подкассами

19. Никакой статический член не может использовать тип параметра, объявленный в его классе:

public class WrongGenericClass<T> {
   static Т data; // Неверно, нельзя создать статические переменные типа Т

   static Т getData() {
     return  data; }  // Неверно, ни один статический метод не может использовать Т
}

20. Нельзя объявить статические члены, использующие обобщённый тип. Но можно объявлять
    обобщённые статические методы, определяющие их собственные параметры типа.

21. Обобщённый класс не может расширять класс Throwable. Значит, создать обобщённые классы
    исключений невозможно.

22. Класс ArrayList, как и все коллекции в целом, может работать только с ссылочными типами
    данных. Для хранения примитивов необходимо использовать “обертки”: Byte, Short, Integer, Long,
    Float, Double, Character, Boolean.

23. Выводы по ДЗ3: прежде чем проводить какие-то вычисления необходимо проверить корректность входных данных, иначе к концу вычеслений может выясниться, что данные не верны и программа упадет затратив перед этим ресурсы.

24. Внутри обобщенного класса нельзя создавать объекты обобщеного типа:
void doSomething() {
   T obj = new T();
 }
 также нельзя создавать дженирализованные массивы: Т[] array = new T[10]; // так нельзя

25. В  дженериках наследование не работает, те. нельзя написать : GenBox<Number> gbx = new GenBox<Integer>(123); в правой части выражения должен быть тот же тип, что и в левой GenBox<Integer> gbx = new GenBox<Integer>(123);

26. public static void doSomething(GenBox<? super Number>) {} означает что метод принимает GenBox параметризованый Number или его родителями.

27. Существуют тажке параметризованные интерфейсы, например Comparable<>, его удобно применять при сравненни классов, например
    Class Box implement Comparable<Box> {

    @override
    comareTo(Box o) {
        return this.size - o.size;
    }
    }

28. Метод copy(List<? super T> consumer, List<? extends T> producer) PECS. Допустим consumer - лист животных, а producer - лист котов. Котов можно скопировать в лист животных, а животных в лист котов нельзя.

29. Varargs может быть только один, и должен стоять последним в списке аргументов.

////////////////////////COLLECTIONS//////////////////////
30. Начальная емкость ArrayList = 10 элементам и по мерер расширения увеличивается в 1.5 раза

31. Пример удалить все буквы "В" в листе: while(list.remove("B");

32. При создании новых классов если предполагается их сравнение у них нужно переопределить методы equals(), hashcode();

33. Отсортировать коллекцию можно двумя способоми:
    1. вызывать у коллекции метод sort(Comparator<? super T> c)
    2. вызвать у утильного класса Collections метод sort(Collection c, Comparator <? super T> c) переадав в него коллекцию и компаратор, пример:

    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "BBB", "CC", "GGGGG", "YYYY"));
        list.sort((o1, o2) -> o1.length() - o2.length()); // Способ 1
        Collections.sort(list, (o1, o2) -> o1.length() - o2.length()); // Способ 2

        System.out.println(list);
    }

34. Поиск элемента по индексу в LinkedList происходит путем прохода по всем элементам начиная с первого (или последнего) и подсчета количества переходов. Поэтому поиск по индексу здесь дольше чем в ArrayList


/////////////////ВОПРОСЫ//////////////////
1. Когда инициализируются статические поля и методы, когда в память загружается класс?
2. Как можно вызвать нестатический метод из статического?
3. Где храниться объект и ссылка на него?
4. Что попадает в стэк при начале выполнения программы?
5. Может ли ссылка на объект храниться в куче?
6. Можно ли пользоваться неинициализированной локальной переменной?
7. Какие переменные инициализируются по умолчанию?
8. Что необходимо сделать, чтобы поля родителя перешли в наследника?
9. Где могут находится абстрактные методы?
10. Какие методя объекта можно вызвать если он ссылается на ссылку родителя Animal animal = new Dog();?
11. Можно объект родителя сослать на ссылку наследника Cat cat = new Animal();? Почему так?
12. Можно ли сослать объекты на ссылку интерфейсного типа, если они имплементируют этот интерфейс Flyable Duck = new Duck();?
13. Что нужно сделать чтобы обратиться к методу объекта имплементирующему несколько интрефейсов?
14. Для чего нужны дефолтне методы?
15. Допустимы ли в названиямх пакетов большие буквы?
16. В какой строке стэектрейс находится место указывающее на ошибку? Что находится в последней строке?
17. В чем смысл пробрасывания исключенрия наверх?
18. Что означает запись <T extends superclass> ?
19. Может ли использоваться дженерик класса статическим членом этого класса? Почему?
20. Можно ли в статическом методе использовать собственные дженерики?
21. Можно ли созадавать обобщеные классы исключений, почему?
22. С какими типами данных работает ArrayList, как организована рабта коллекций с примитивными типами данных?
23. Выводы из ДЗ3
24. Можно ли создавать обобщенные массивы? Т[] array = new T[10];
