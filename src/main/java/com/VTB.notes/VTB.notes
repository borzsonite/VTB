
1. Вся статика инициализируется когда класс загружается в память, класс загружается в память когда к нему впервые обращаются (это может быть обращение к статическому полю, методу, создание объекта)

2. Вызвать нестататический метод из статического можно только через экземпляр класса экземпляр.nonStaticMethod();

3. Объект храниться в куче, ссылка на него храниться в стэке.

4. Когда программа начинает выполняться в стек попдают вызовы методов и локальные переменные

5. Ссылки на объекты храняться в стеке, но если у объекта есть ссылка на другой объект, то такая ссылка будет храниться вместе с объектом в куче.

6. Локальной переменной нельзя пользоваться пока она не инициализирована, т.е локальные переменные по умолчанию не инициализируются.

7. По умолчанию инициализируются поля объектов.

8. Если необходимо чтобы поля родителя перешли к наследникам у них убирается модификатор private.

9. Абстрактные методы могут находится только внутри абстрактного класса.

10. Если объект наследник ссылается на родительскую ссылку:
    Animal animal = new Dog("Bobik", "White", 2);
то по такой ссылке напрямую можно вызывать только методы родителя:
    animal.helloFromAnimal();
    animal.helloFromDog(); // так не работает, потому что теоретически на Animal можно сослать и Dog и Cat и Hamster etc и тогда может возникнуть возможность у хомяка вызвать метод собаки.
чтобы вызвать метод наследника, нужно сделать принудительный каст, явно указав что по ссылке Animal находится Dog
    ((Dog)animal).helloFromDog();

11. Положить в ссылку наследника объект родителя нельзя:
    Cat cat = new Animal(); // так не работает, потому что родитель не знает какие методы есть у наследника.

12. Если несколько классов имплементят один интерфейс их можно положить в переменную этого интерфейса, даже если они сильно отличаются. Например, Interface Flyable, на переменную типа Flyable можно ссылать объекты Duck, Airplane, Fly etc... Flyable fly = new Fly(), Flyable Duck = new Duck().

13. Если в интерфейсную переменную кладется объет релализующий несколько интерфейсов, то для вызовва метода одного из интерфейса, необходимо будет сделать каст к этому интерфейсу, (Swimable) duck.swim(), где swim - метод интерфейса Swimable.

14. Внутренние вложенные классы служать для организации кода, чтобы не выносить наружу то, что требуется лишь контексте внешнего класса. Например класс шахматная клетка имее смысл только в контексте класса шахматная доска, поэтому логично создать внутренний класс клетка внутри класса шахматная доска.

15. Внутренний аннонимный класс имеет название класса в котором он был образован с добаление $порядковыйНомер, например SomeClass$1

14. Смысл дефолтных методов в том, что дефолтные методы могут реализовываться всеми классами имплиментирующими интерфейс, при этом если в каком то классе нужно изменить логику дефолтного метода это не отразится на остальных классах реализующих данный интерфейс.

15. В назаваниях пакетов большие буквы недопустимы.

16. В распечатке stacktrace место, которое вызвало ошибку печатся во второй строке, например:
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at com.lesson3.MainApp.a(MainApp.java:14) // 3. здесь возникла ошибка
    	at com.lesson3.MainApp.b(MainApp.java:9) // 2. потом был вызов сюда
    	at com.lesson3.MainApp.main(MainApp.java:5) // 1.  путь к ошибке начался отсюда

17. Смысл пробрасывания исключения наверх не в том, чтобы загасить его в самом начале (в месте откуда оно вылетело), а в том чтобы обработать его на том этапе где это будет максимально полезно с точки зрения логики работы программы

////////////////////Lesson 4. Generis, Collections//////////////////////

18. Запись <T extends superclass> означает, что параметр Т может быть заменен только суперклассом или его подкассами

19. Никакой статический член не может использовать тип параметра, объявленный в его классе:

public class WrongGenericClass<T> {
   static Т data; // Неверно, нельзя создать статические переменные типа Т

   static Т getData() {
     return  data; }  // Неверно, ни один статический метод не может использовать Т
}

20. Нельзя объявить статические члены, использующие обобщённый тип. Но можно объявлять
    обобщённые статические методы, определяющие их собственные параметры типа.

21. Обобщённый класс не может расширять класс Throwable. Значит, создать обобщённые классы
    исключений невозможно.

22. Класс ArrayList, как и все коллекции в целом, может работать только с ссылочными типами
    данных. Для хранения примитивов необходимо использовать “обертки”: Byte, Short, Integer, Long,
    Float, Double, Character, Boolean.

23. Выводы по ДЗ3: прежде чем проводить какие-то вычисления необходимо проверить корректность входных данных, иначе к концу вычеслений может выясниться, что данные не верны и программа упадет затратив перед этим ресурсы.

24. Внутри обобщенного класса нельзя создавать объекты обобщеного типа:
void doSomething() {
   T obj = new T();
 }
 также нельзя создавать дженирализованные массивы: Т[] array = new T[10]; // так нельзя

25. В  дженериках наследование не работает, те. нельзя написать : GenBox<Number> gbx = new GenBox<Integer>(123); в правой части выражения должен быть тот же тип, что и в левой GenBox<Integer> gbx = new GenBox<Integer>(123);

26. public static void doSomething(GenBox<? super Number>) {} означает что метод принимает GenBox параметризованый Number или его родителями.

27. Существуют тажке параметризованные интерфейсы, например Comparable<>, его удобно применять при сравненни классов, например
    Class Box implement Comparable<Box> {

    @override
    comareTo(Box o) {
        return this.size - o.size;
    }
    }

28. Метод copy(List<? super T> consumer, List<? extends T> producer) PECS. Допустим consumer - лист животных, а producer - лист котов. Котов можно скопировать в лист животных, а животных в лист котов нельзя.

29. Varargs может быть только один, и должен стоять последним в списке аргументов.

////////////////////////COLLECTIONS//////////////////////
30. Начальная емкость ArrayList = 10 элементам и по мерер расширения увеличивается в 1.5 раза

31. Пример удалить все буквы "В" в листе: while(list.remove("B");

32. При создании новых классов если предполагается их сравнение у них нужно переопределить методы equals(), hashcode();

33. Отсортировать коллекцию можно двумя способоми:
    1. вызывать у коллекции метод sort(Comparator<? super T> c)
    2. вызвать у утильного класса Collections метод sort(Collection c, Comparator <? super T> c) переадав в него коллекцию и компаратор, пример:

    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "BBB", "CC", "GGGGG", "YYYY"));
        list.sort((o1, o2) -> o1.length() - o2.length()); // Способ 1
        Collections.sort(list, (o1, o2) -> o1.length() - o2.length()); // Способ 2

        System.out.println(list);
    }

34. Поиск элемента по индексу в LinkedList происходит путем прохода по всем элементам начиная с первого (или последнего) и подсчета количества переходов. Поэтому поиск по индексу здесь дольше чем в ArrayList

/////////////////////Lesson5 07.04.2021//////////////////////
35. Рехэшинг пересчет хэшей элементов в хэшмэп при увлеличении ее емкости

36. Loadfactor в хэшмапе указывает на то насколько должна быть заполнена хэшмэп, чтобы начачть увеличиваться (увеличение происходит в 2 раза)

37. метод HashMap.getOrDefault(key, DefaultValue), если ключ существует возвращает содержащееся по нему значение, иначе возвращет DefaultValue

38. HashMap<> не гарантирует порядко добавления/извлечения, если необходим порядок нужн использовать LinkedHashMap<>. TreeMap<> хранить значения в упорядоченном по ключу виде.

39. Интерфейс Set реализуется классами ashSet<> - порядок добавления/извлечения не гарантируется, LinkedHashSet - порядок гарантируется, TreeSet - хранит значения в отсортированом виде.

40. Особенность Set - в нем храняться только уникальные значения.

41. HashMap позволяет использовать null в  качестве ключей и значений, HashTable - не позволяет. Еще отличие HashMap не synchronized, HashTable synchronized

42. Vector и  ArrayList практически то же самое, различие Vector- synchronized, ArrayList - не synchronized

43. В момомент обхода коллекции (напр. foreach) ее нельзя модифицировать (удалалять, добавлять элементы)

44. Стандартный алгоритм обхода и изменения коллекции:
         List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "A"));
         Iterator<String> iterator = list.iterator(); // 1. Создаем итератор
            while(iterator.hasNext()) { // 2. Обходим коллекцию пока в ней есть следующее значение
              if(iterator.next().equals("A")) { // 3. Если условие выполняется
                 iterator.remove(); // 4. Производим действие
                }

45.  Iterator подходит для обхода Set и  List, для обхода HashMap Iterator не подходит. Но это ограничение можно обойти если применить итератор к EntrySet мапы. - map.entrySet().iterator();

46. Для обхода листов предусмотрен более специализированный listIterator() у которого есть большее количество методов для работы с листами. list.listIterator().nextIndex();

47. Простой способ вывести все пары ключ:значение в мапе:
    data.forEach((x,y)-> System.out.println(x + ": " + y));

/////////////////Lesson6//////////////////////
48. Поток демон будет работать пока работает хотя бы один обычный Поток. Как только все обычные Потоки завершаться демон тоже завершается.

49. Для остановки потока испльзуется метод thread.interupt(), затем в безопасном месте кода делается проверка на thread.isinterupted(), если возвращается true делается выход из потока.

50. При испольовании synchronized при вызове метода в качестве монитора испльзуется this, т.е. объект на котором был вызван метод.

51. Смысл обработки InteruptedException в том, что кто-то может попытаться оставновить поток который в данный момент недоступен (спит) в этом случае нужно предпринять какие то действия.

52. Синхронизированным можно делать не весь, а часть метода,

public class Test1 {
    Object monitor = new Object();

    public static void main(String[] args) {
        Test1 monitor = new Test1();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();
        new Thread(() -> monitor.method()).start();

    }

    public void  method() {
        // non synchronized block --> сюда зайдут три потока одновременно !!!!!!!!!!!!!!
        System.out.println(Thread.currentThread().getName() + " non sync starts");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // synchronized block --> а сюда только по очереди !!!!!!!!!!!!!!
        synchronized (monitor) {
            System.out.println(Thread.currentThread().getName() + " sync starts");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

53. Если метод статический, то в качестве монитора выступает сам класс и доступ к такому методу одномоментно имеет только один поток.

54. Как только синхронизированный метод любого объекта получает управление, объект блокируется и ни один синхронизированный метод этого объекта не может быть вызван другим потоком. Скорее всего так потому, что объект блокируется по this, если в synchronized передавать разные объекты, то можно вызывать синхронизованные методы и блоки кода если они лочаться разными мониторами.

55. Если во внутренний (анонимный) класс передается извне какая-то переменная, то эта переменаня должна быть либо final, либо effectivly final

56. Существует 3 вида ThreadPool: 1. FixedTreadPool(4) - на определенной количество потоков, SingleThreadPool - на 1 поток, CachedThreadPool - на неограниченное количество потоков.

57. Если синхронизованный блок занят каким то потоком, то остальные потоки, которым тоже нужно попасть в этот блок, будут ждать (и ничего не делать) пока освободиться этот блок.

58. Hashtable лучше не использовать, потому что в качестве монитора выступает сама таблица соответственно она блокируется целиком. В этом случае лучше брать concurrentHashMap/

59. Преимущество CuncurrentHashTable в том, что при записи блокируется только та ячейка в которую проводится запись остальные ячейки остаются незаблокированными.

60. Для получения синхронизированнной коллекции из обычной можно использовать методы класса Collections
     Collections.synchronizedList()
     Collections.synchronizedMap()
     Collections.synchronizedSet()

     //////////////////////LESSON 8 Stream API////////////////////////////

61. При работе стрима исходная коллекция не меняется.

62. Простой способ получить заполненный лист List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
передать в конструктор лист.

63. Метод .map() служит для преобразования одних типов объектов в другой тип, например преобразование стрингов в интеджер
  Stream.of("AA", "D", "CCC", "NN").map(s -> s.length()).forEach(System.out::println); // 2 1 3 2
  или могут проводиться операции над одними типами например интеджер в интеджер:
    Stream.of(1, 2, 3, 4).map(s -> s + 1).forEach(System.out::println); // 2 3 4 5

64. Ссылка на метод примеры код в файле Test1.java:
 Stream.of("aa", "bb").map(String::length).forEach(System.out::println); // для каждого объекта типа String в потоке вызвать метод .length()
 Stream.of("aa", "bb").map(s -> s.length()).forEach(System.out::println); // то же самое

 Stream.of("Bob", "Mike", "Jhon").map(User::new).forEach(User::getName); // для каждого объекта типа User в потоке вызвать метод new() т.е. конструктор, а затем метод .getName();
 Stream.of("Bob", "Mike", "Jhon").map(s-> new User(s)).forEach(s -> s.getName()); // то же самое

65. Метод limit(n) оставляет в стриме n первых объектов.

66. Метод .distinct() оставляет в стриме только уникальные элементы:
        Arrays.asList(1,2,3,4,1,2,2).stream().distinct().forEach(System.out::println); // 1 2 3 4
        Arrays.asList("Jhon", "Mike", "Jhon").stream().distinct().forEach(System.out::println); // Jhon Mike

67. //math example
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().allMatch(s -> s > 0)); // true. Все элементы больше 0
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().anyMatch(s -> s > 10)); // false. Хоть один элмент стрима больше 10
    System.out.println(Arrays.asList(1,2,3,4,5,6,7).stream().noneMatch(s -> s == 7)); // false. Не один элемент не равен 7

68. .findAny() // возвращает Optional т.е. если объект есть возвращается этот объект обернутый в  Optional, если нет возвращается Optional.empty

69. Лямбды и ссылки на методы можно записывать в переменные и затем передавать в стримы, напр.:
        Consumer<Integer> consumer = System.out::println; // 1.1 Записываем в переменную ссылку на метод и
        Consumer<Integer> consumer1 = s -> System.out.print(s); 2.1 Записываем в переменную лямбду и

        Stream.of(1,2,3,4,5,1,2,3,4,5).forEach(consumer); // 1.2 передаем ее в качестве аргумента в стрим
        Stream.of(1,2,3,4,5,1,2,3,4,5).forEach(consumer1);2.2. передаем ее в качестве аргумента в стрим

70. // .reduce() example Служит для сжатия стрима в один объект, например:
    System.out.println(Stream.of(1,2,3,4).reduce(0, (a,b) -> a+b)); // стрим интеджеров преобразуется в сумму его значений.

71. Существуют специфические виды стримов IntStream, LongStream, DoubleStream которые содержат  специфические методы для работы с числами sum() avarage()

72. .mapToInt() example, метод служит для преобразования стрима объектов в стрим интов, например:
Stream.of(new User2("Bob", 20)).mapToInt(User2::getAge).forEach(System.out::println); // 20

73. .skip(n) // пропускает первые n элементов стрима

74. Работа с файлом через стримы. Задача посчитать длину каждой строки в файле
    Files.lines(Paths.get("123.txt")).map(String::length).forEach(System.out::println); // .lines() возвращает стрим Стрингов

75. Работа со строками через стрим. Задача посчитать количество уникальных слов в строке.

76. .limit(n) оставляет n первых элементов стрима, .skip(n) пропускает n первых элементов и оставляет оставшиеся

///////////////////////////lesson 9 Reflection API

77. Начальной точкой работы с рефлешн api является получение ссылки на объект Class. Существует 3 способа получить объект типа Class:
      Class stringClass1 = "Java".getClass();
      Class stringClass2 = String.class;
      Class stringClass3 = Class.forName("java.lang.String");

78. Class.getDeclaredMethods() возвращает массив всех методов объявленных в классе (кроме унаследованных)

79. Class.getMethods() возвращает массив всех публичных методы объявленных в классе (включая унаследованные)

80. Вызвать метод через рефлекшен можно так: method[0].invoke(cat), где Cat cat = new Cat() - конкретный объект метод которого вызывается, method[0] метод возвращенный через .getDeclaredMethods() или .getMethods() т.е. элемент массива методов Класса;

81.   Получение модификаторов
       int mod = methods[0].getModifiers(); // methods[0] получили через Class.getDeclaredMethods()
       System.out.println("is static: " + Modifier.isStatic(mod));
       System.out.println("is final: " + Modifier.isFinal(mod));
       System.out.println("is private: " + Modifier.isPrivate(mod));
       System.out.println("is public: " + Modifier.isPublic(mod));

82. Получение массива полей  Field[] fields = catClass.getDeclaredFields();

83. Все операции с полями аналогчны операциям с методами.

84. Создание объектов возмжно через (Class) Class.newInstance(), напр.
    Cat cat2 = (Cat) catClass.newInstance(); // создание объекта у которого есть дефолтный конструктор (или без параметров)

85. Если необходимо создать объект у которого конструктор принимает параметры, сделать это можно передав в .getConstructor() и .newInstace() необходимые парметры.
        Cat cat3  = (Cat) catClass.getConstructor(int.class, int.class, int.class, int.class)
                .newInstance(20, 300, 40, 50); // вызывается конструктор с 4-мя параметрами.
        System.out.println(cat3);

86. За загрузку классов в java отвечают ClassLoader'ы, например
ClassLoader classLoader = new URLClassLoader(new URL[] {new File("C:\\Users\\Alpha\\Documents\\java").toURL()}); // загрузка класса находящегося в папке C:\Users\Alpha\Documents\java

87. После загрузки класса с ним можно начинать работать:
        ClassLoader classLoader = new URLClassLoader(new URL[] {new File("C:\\Users\\Alpha\\Documents\\java").toURL()}); // загружаем классы находящиеся по указанному пути
        Class humanClass = classLoader.loadClass("Human"); // получаем ссылку на объект Class класса Human
        Object humanObject = humanClass.getConstructor(String.class, int.class).newInstance("Bob", 30); // создаем объект класса Human и ссылаем его на Object
        Method[] method = humanObject.getClass().getDeclaredMethods(); // получаем методы у класса Human
        method[0].invoke(humanObject); // вызываем метод у Human

88. Аннотация выглядит следующим образом:

    @Retention(RetentionPolicy.RUNTIME) // Аннотацию можно использовать в runtime
    @Target(ElementType.METHOD) // В качестве таргета - метод.
    public @interface MyAnnotation {
        int priority() default 5; // в аннотацию можно подшивать доплнительную информацию в виде параметров.
    }

89. Вместо priority в качестве дополнительного параметра можно указывть timeout, времы выполнения и многое другое

90. Обратиться к параметрам аннотации можно чере конструкцию:
    classMember.getAnnotation(MyAnnotation.class).priority(), где classMember - поле или метод, priority() - параметр

91. jdbc представляет собой набор интерфейсов для взаимодействия с базами данных sql

92. Алгоритм работы с БД через идеа следующий:
    - подключаем jdbc драйвер -> pom.xml -> <dependencies> <dependency> копируем код с рипозитория мавена sqlite-jdbc
    - создаем поля для конекшена и стейтмента:
        - Connection connection;
        - Statement statement;
    - создаем два метода .connect() .disconnect() в которых прописываем логику.
    - в .connect() в блоке try
        - Class.forName("org.sqlite.JDBC"); // загружаем драйвер
        - connection = DriverManager.getConnection("jdbc:sqlite:main.db"); // создаем коннекшн
        - statement = connection.createStatement(); // создаем стейтмент
        - в catch ловим ClassNotFoundException | SQLException e
    - в .disconnect()
        - закрываем в обратном порядке, сначала стейтмент statement.close()
        - connection.close

93. В методе main() вызываем .connect()

94. Обращение к базе происходит через стейтмент после коннекта к базе, напр: statement.executeUpdate("комманда SQL")

95. .executeUpdate("комманда SQL") возвращает интовое значение соответствующее количеству строк подвергшихся изменению

96. В ответ на запрос в любом случае возвращается таблица, котрая запсывается в ResultSet

97. ResultSet.next() возвращает true если запись в таблице содержит значения, либо false если значений нет. Т.е. пока rs.next() == true, в таблице есть значения, как только rs.next() == false значит значений нет.

98. Алгоритм печати таблицы полученной в ResultSet:
      try(ResultSet rs = statement.executeQuery("SELECT * from students")) {
          while(rs.next()) {
             System.out.println(rs.getInt(1) + " " + rs.getString("name") + " " + rs.getInt(3));
            }
                }
        } catch (SQLException e) {
            e.printStackTrace();
        } // в getInt() , getString() можно передавать либо имя столбца, либо его номер.
       }

99. Алгоритм вставки в таблицу
        static void tableInsert() {
            try {
                statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob4', 100);");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

100. Алгоритм обновления данных в таблице
        static void tableUpdate() {
            // обновление данных в таблице
            try {
                statement.executeUpdate("UPDATE students SET  score = 200 WHERE id = 1");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

101. Алгоритм очистки таблицы
        static void tableClear() {
             try {
                 statement.executeUpdate("DELETE FROM students");
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }


102. Алгоритм удаления записи из таблицы
         static void tableDelete() {
             try {
                 statement.executeUpdate("DELETE FROM students WHERE id = 4");
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }

103. Работа с PreparedStatement
    - У класса задается поле private static PreparedStatement preparedStatement;
    - в методе .connect() создается шаблон:
    preparedStatement = connection.prepareStatement("INSERT INTO students (name, score) VALUES (?,?); ");
    - в методе .main() делается обращение к preparedStatement:
        preparedStatement.setString(1, "Bob"+ i); // 1- индекс параметра
        preparedStatement.setInt(2, 50); // 2- индекс параметра
        preparedStatement.executeUpdate(); // запуск на выполнение

104. При работе с PreparedStatement в случае если точно не известен тип значения в ячейке, то вместо setInt(), setString() можно указывать setObject();

105. Для ускорения скорости транзакций можно отключать автокомит
       connection.setAutoCommit(false); // отключили вызов комита для каждой транзакции
            for(int i=0; i<10000; i++) {
               preparedStatement.setString(1, "Bob"+ i);
               preparedStatement.setInt(2, 50);
               preparedStatement.executeUpdate();
            }
       connection.commit(); сделали коммит для всех запросов
    + в увеличении скорости
    - возможная потеря данных, если произойдет сбой, на 9999 транзакции никакие данные в таблицу не запишутся.

106. Также транзакции можно предварительно аккумулировать с помощью .addBatch() и затем комитить сразу все пачку запросов
        static void preparedStatementBatchEx() {
            try {
                for(int i=0; i<10000; i++) {
                    preparedStatement.setString(1, "Bob"+ i);
                    preparedStatement.setInt(2, 50);
                    preparedStatement.addBatch(); // добавляем в batch
                }
                preparedStatement.executeBatch(); // выполняем batch
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

107. В код можно вставлять точки сохранения после выплнения запроса и делать к ним откаты, например:
       statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob1', 1000);");
        Savepoint sp1 = connection.setSavepoint(); // точка сохранения
        statement.executeUpdate("INSERT INTO students (name, score) VALUES ('Bob2', 1000);");
        connection.rollback(sp1); // откат к sp1



/////////////////ВОПРОСЫ//////////////////
1. Когда инициализируются статические поля и методы, когда в память загружается класс?
2. Как можно вызвать нестатический метод из статического?
3. Где храниться объект и ссылка на него?
4. Что попадает в стэк при начале выполнения программы?
5. Может ли ссылка на объект храниться в куче?
6. Можно ли пользоваться неинициализированной локальной переменной?
7. Какие переменные инициализируются по умолчанию?
8. Что необходимо сделать, чтобы поля родителя перешли в наследника?
9. Где могут находится абстрактные методы?
10. Какие методя объекта можно вызвать если он ссылается на ссылку родителя Animal animal = new Dog();?
11. Можно объект родителя сослать на ссылку наследника Cat cat = new Animal();? Почему так?
12. Можно ли сослать объекты на ссылку интерфейсного типа, если они имплементируют этот интерфейс Flyable Duck = new Duck();?
13. Что нужно сделать чтобы обратиться к методу объекта имплементирующему несколько интрефейсов?
14. Для чего нужны дефолтне методы?
15. Допустимы ли в названиямх пакетов большие буквы?
16. В какой строке стэектрейс находится место указывающее на ошибку? Что находится в последней строке?
17. В чем смысл пробрасывания исключенрия наверх?
18. Что означает запись <T extends superclass> ?
19. Может ли использоваться дженерик класса статическим членом этого класса? Почему?
20. Можно ли в статическом методе использовать собственные дженерики?
21. Можно ли созадавать обобщеные классы исключений, почему?
22. С какими типами данных работает ArrayList, как организована рабта коллекций с примитивными типами данных?
23. Выводы из ДЗ3
24. Можно ли создавать обобщенные массивы? Т[] array = new T[10];
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
25. Как работает наследование в дженериках, можно ли написать GenBox<Number> gbx = new GenBox<Integer>(123);?
26. Что означает public static void doSomething(GenBox<? super Number>) {} ?
27. Пример использования параметризованного интерфейса
28. Принцип PECS на примере листа животных и собак
29. Особенности применения varargs
30. Какова начальная емкость ArrayList и как она меняется?
31. Удаление всех элементов в ArrayList в одну строку?
32. Что нужно сделат у классов если предполагается их сравнение?
33. Два способа отсортировать коллекцию.
34. Как происходит поиск элемента по индексу в LinkedList?
35. Что такое рехэшинг мапы?
36. Что такое Loadfactor в хэшмапе?
37. Что делает метод HashMap.getOrDefault(key, DefaultValue) ?
38. В чем различия между HashMap<>, LinkedHashMap<>,  TreeMap<> ?
39. Какми классами реализуетсяИнтерфейс Set? В чем между ними различие?
40. В чем особенность Set?
41. В чем различие между HashTable и HashMap?
42. В чем различие между Vector и  ArrayList?
43. Чего нельзя делать при обходе коллекции через foreach?
44. Станадртный алгоритм обхода и изменения коллекции.
45. Для обхода каких коллекций подходит Iterator, что насчет HashMap?
46. Для чего предназначен listIterator?
47. Простой способ обхода мапы?
48. До каких пор будет работать поток демеон, когда он прекратит работу?
49. Что делает метод .interupt() у потока?
50. Что испльзуется в качестве монитора в synchronized методе?
51. В чем смысл обработки InteruptedException?
52. Можно ли синхронизировать не весь, а часть метода?
53. Что выступает в качестве монитора для статического метода?
54. Что происходит когда синхронизированый метод получает управление?
55. Какое условие должно соблюдаться при передаче переменной во внутренний (анонимный) класс?
56. Какие  3 вида ThreadPool существует?
57. Что будут делать потоки которым нужно попасть в синхронизованный блок, который уже занят?
58. Почему для синхранизации Hashtable лучше не использовать, что лучше использовать?
59. В чем преимущество ConcurrentHashTable?
60. Как получить синхронизированную коллекцию из обычной?
61. Меняется ли исходная коллекция при работе стрима?
62. Как получить коллекцию (лист) заполненный значениями?
63. Для чего служит метод .map() ?
64. Примеры использовария .map() ?
65. Для чего служить метод limit(n) ?
66. Что делает метод  .distinct() ?
67. Примеры использовария .match() ?
68. Что делает .findAny() ?
69. Что можно делать с лямбдами и ссылками на метод и куда передавать?
70. Что делает .reduce() ?
71.  Какие специфические виды стримов существуют?
72. Для чего служит .mapToInt() ?
73. ДЛя чего служит .skip(n) ?
74. Как посчитать длину каждой строки в файле?
75. Как посчитать количество уникальных слов в строке?
76. Для чего служат методы .limit(n) .skip(n) ?
77. С чего начинается работа с рефлекшн api? Три способа получить ссылку на Class?
78. Что возвращает Class.getDeclaredMethods() ?
79. Что возвращает Class.getMethods() ?
80. Как вызвать метод у объекта через рефлекшн?
81. Как плучить модификаторы членов у объекта?
82. Как получить массив полей объекта?
83. В чем отличие операций с полями от операций с методами?
84. Как создать объект через рефлектион?
85. Как создать объект через конструктор с парметрами?
86. Как загрузить класс не являющийся частью проекта?
87. Алгоритм работы с загруженным классом?
88. Из чего состоит аннотация?
89. Что можно указать в качестве параметра у аннотации?
90. Как обратиться к параметру аннотации?
91. Что   представляет собой jdbc?
92. Алгоритм подключеия БД в идеа?
93. Что вызывается в .main() для подключения?
94. Через что происходит обращение и работа с БД?
95. Что возвращает .executeUpdate("комманда SQL") ?
96. Что записывает в ResultSet?
97. Что возвращает ResultSet.next()? До какого момента можно обходить БД?
98. Как вывести таблицу из ResultSet?
99. Алгоритм вставки в таблицу?
100. Алгоритм обновления записи в таблице?
101. Алгоритм очистки таблицы?
102. Алгоритм удаления записи из таблицы?
103. Что такое PreparedStatement, как с ним работать?
104. Что можно указать в setInt(), setString() если неизвестен тип данных в ячейке?
105. Что можно сделать для ускорения скорости транзакций?