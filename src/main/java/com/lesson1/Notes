
1. Вся статика инициализируется когда класс загружается в память, класс загружается в память когда к нему впервые обращаются (это может быть обращение к статическому полю, методу, создание объекта)

2. Вызвать нестататический метод из статического можно только через экземпляр класса экземпляр.nonStaticMethod();

3. Объект храниться в куче, ссылка на него храниться в стэке.

4. Когда программа начинает выполняться в стек попдают вызовы методов и локальные переменные

5. Ссылки на объекты храняться в стеке, но если у объекта есть ссылка на другой объект, то такая ссылка будет храниться вместе с объектом в куче.

6. Локальной переменной нельзя пользоваться пока она не инициализирована, т.е локальные переменные по умолчанию не инициализируются.

7. По умолчанию инициализируются поля объектов.

8. Если необходимо чтобы поля родителя перешли к наследникам у них убирается модификатор private.

9. Абстрактные методы могут находится только внутри абстрактного класса.

10. Если объект наследник ссылается на родительскую ссылку:
    Animal animal = new Dog("Bobik", "White", 2);
то по такой ссылке напрямую можно вызывать только методы родителя:
    animal.helloFromAnimal();
    animal.helloFromDog(); // так не работает, потому что теоретически на Animal можно сослать и Dog и Cat и Hamster etc и тогда может возникнуть возможность у хомяка вызвать метод собаки.
чтобы вызвать метод наследника, нужно сделать принудительный каст, явно указав что по ссылке Animal находится Dog
    ((Dog)animal).helloFromDog();

11. Положить в ссылку наследника объект родителя нельзя:
    Cat cat = new Animal(); // так не работает, потому что родитель не знает какие методы есть у наследника.

12. Если несколько классов имплементят один интерфейс их можно положить в переменную этого интерфейса, даже если они сильно отличаются. Например, Interface Flyable, на переменную типа Flyable можно ссылать объекты Duck, Airplane, Fly etc... Flyable fly = new Fly(), Flyable Duck = new Duck().

13. Если в интерфейсную переменную кладется объет релализующий несколько интерфейсов, то для вызовва метода одного из интерфейса, необходимо будет сделать каст к этому интерфейсу, (Flyable) duck.swim(), где swim - метод интерфейса Swimable.

14. Смысл дефолтных методов в том, что дефолтные методы могут реализовываться всеми классами имплиментирующими интерфейс, при этом если в каком то классе нужно изменить логику дефолтного метода это не отразится на остальных классах реализующих данный интерфейс.

15. В назаваниях пакетов большие буквы недопустимы.

16. В распечатке stacktrace место, которое вызвало ошибку печатся во второй строке, например:
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at com.lesson3.MainApp.a(MainApp.java:14) // 3. здесь возникла ошибка
    	at com.lesson3.MainApp.b(MainApp.java:9) // 2. потом был вызов сюда
    	at com.lesson3.MainApp.main(MainApp.java:5) // 1.  путь к ошибке начался отсюда

17. Смысл пробрасывания исключения наверх не в том, чтобы загасить его в самом начале (в месте откуда оно вылетело), а в том чтобы обработать его на том этапе где это будет максимально полезно с точки зрения логики работы программы

////////////////////Lesson 4. Generis, Collections//////////////////////

18. Запись <T extends superclass> означает, что параметр Т может быть заменен только суперклассом или его подкассами

19. Никакой статический член не может использовать тип параметра, объявленный в его классе:

public class WrongGenericClass<T> {
   static Т data; // Неверно, нельзя создать статические переменные типа Т

   static Т getData() {
     return  data; }  // Неверно, ни один статический метод не может использовать Т
}

20. Нельзя объявить статические члены, использующие обобщённый тип. Но можно объявлять
    обобщённые статические методы, определяющие их собственные параметры типа.

21. Обобщённый класс не может расширять класс Throwable. Значит, создать обобщённые классы
    исключений невозможно.

22. Класс ArrayList, как и все коллекции в целом, может работать только с ссылочными типами
    данных. Для хранения примитивов необходимо использовать “обертки”: Byte, Short, Integer, Long,
    Float, Double, Character, Boolean.

23.

/////////////////ОТВЕТЫ//////////////////
1. Когда инициализируются статические поля и методы, когда в память загружается класс?
2. Как можно вызвать нестатический метод из статического?
3. Где храниться объект и ссылка на него?
4. Что попадает в стэк при начале выполнения программы?
5. Может ли ссылка на объект храниться в куче?
6. Можно ли пользоваться неинициализированной локальной переменной?
7. Какие переменные инициализируются по умолчанию?
8. Что необходимо сделать, чтобы поля родителя перешли в наследника?